#!/bin/bash

type _comp_filter &> /dev/null || return
type _comp_contains &> /dev/null || return
type _comp_remove_list &> /dev/null || return
type _comp_filter_shorts &> /dev/null || return

function attack_mode() {
	# when a certain attack mode was specified, we need to remove / add some attack-specific
	# options. This is done by this function.
	tmp=$@

	for var in $(echo ${COMP_LINE} | sed -e 's/ /\n/g'); do
		if [[ "$var" == "--aimed-flip" ]] || [[ "$var" == "--bit-flip" ]]; then
			tmp="$tmp --end-block"
			tmp="$tmp --end-byte"
			tmp="$tmp --start-block"
			tmp="$tmp --start-byte"
			tmp=$(remove_attack_modes $tmp)
		fi

		if [[ "$var" == "--bit-flip" ]]; then
			tmp="$tmp --min-byte"
			tmp="$tmp --max-byte"
		elif [[ "$var" == "--padding" ]] || [[ "$var" == "--shuffle" ]]; then
			tmp=$(remove_attack_modes $tmp)
		fi
	done

	echo $tmp
}

function _ccm() {

    local cur prev words cword cline attack_modes not_complete

    _init_completion || return
    _count_args 

    cline="${COMP_LINE}"
    COMPREPLY=()

    attack_modes="--aimed-flip --bit-flip --padding --shuffle"
    not_complete="--aimed-flip --start-block --start-byte --end-block --end-byte --min-byte --max-byte"

    # complete supported block sizes
	if [[ "$prev" == "--blocksize" ]]; then
		opts="8 16 32"

    # when we are in the second arg of --aimed-flip, complete nothing
    elif [[ ${words[$((cword - 2))]} == "--aimed-flip" ]]; then
        return 0

    # complete possible encodings
	elif [[ "$prev" == "--encoding" ]]; then
		opts="b64 hex"

	# when an options requires a non guessable argument, complete nothing
	elif _comp_contains "$not_complete" "$prev"; then
		return 0

    elif _comp_contains "--aimed-flip --bit-flip"; then

	else 
        opts=$(_parse_help "$1")
	fi

    if _comp_contains "$cline" "$attack_modes"; then
        _comp_remove_list "opts" "$attack_modes";
    fi

    _comp_filter "opts"
    _comp_filter_shorts "opts"

	mapfile -t COMPREPLY < <(compgen -W "${opts}" -- "${cur}") 
	return 0
}

complete -F _ccm ccm
